From b7c6c77a0685e2fcd2c0d8bda0a0946e6515ba0f Mon Sep 17 00:00:00 2001
From: chalesyu <574249312@qq.com>
Date: Tue, 2 Nov 2021 00:00:00 +0800
Subject: [PATCH 5/7] debug dram

---
 arch/arm/mach-sunxi/dram_sun50i_h6.c | 41 ++++++++++++++++++++++++----
 1 file changed, 35 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-sunxi/dram_sun50i_h6.c b/arch/arm/mach-sunxi/dram_sun50i_h6.c
index d05375c902..f3ecccf8fa 100644
--- a/arch/arm/mach-sunxi/dram_sun50i_h6.c
+++ b/arch/arm/mach-sunxi/dram_sun50i_h6.c
@@ -42,27 +42,34 @@ static bool mctl_channel_init(struct dram_para *para);
 static bool mctl_core_init(struct dram_para *para)
 {
 	mctl_sys_init(para);
+	debug("mctl_sys_init ok\n");
 	mctl_com_init(para);
+	debug("mctl_com_init ok\n");
 	switch (para->type) {
 	case SUNXI_DRAM_TYPE_LPDDR3:
 	case SUNXI_DRAM_TYPE_DDR3:
+		debug("doing mctl_set_timing_params\n");
 		mctl_set_timing_params(para);
 		break;
 	default:
 		panic("Unsupported DRAM type!");
 	};
+	debug("doing mctl_channel_init \n");
 	return mctl_channel_init(para);
 }
 
 /* PHY initialisation */
 static void mctl_phy_pir_init(u32 val)
 {
+	debug("doing mctl_phy_pir_init \n");
 	struct sunxi_mctl_phy_reg * const mctl_phy =
 			(struct sunxi_mctl_phy_reg *)SUNXI_DRAM_PHY0_BASE;
 
 	writel(val, &mctl_phy->pir);
 	writel(val | BIT(0), &mctl_phy->pir);	/* Start initialisation. */
+
 	mctl_await_completion(&mctl_phy->pgsr[0], BIT(0), BIT(0));
+	debug("doing mctl_phy_pir_init end \n");
 }
 
 enum {
@@ -168,6 +175,7 @@ static void mctl_sys_init(struct dram_para *para)
 	clrbits_le32(&ccm->dram_clk_cfg, DRAM_MOD_RESET);
 
 	udelay(5);
+	debug("clear reg ok\n");
 
 	/* Set PLL5 rate to doubled DRAM clock rate */
 	writel(CCM_PLL5_CTRL_EN | CCM_PLL5_LOCK_EN |
@@ -180,11 +188,14 @@ static void mctl_sys_init(struct dram_para *para)
 	writel(BIT(RESET_SHIFT), &ccm->dram_gate_reset);
 	udelay(5);
 	setbits_le32(&ccm->dram_gate_reset, BIT(0));
+	debug("Configure DRAM mod clock ok\n");
 
 	/* Disable all channels */
 	writel(0, &mctl_com->maer0);
 	writel(0, &mctl_com->maer1);
 	writel(0, &mctl_com->maer2);
+	debug("Disable all channels ok\n");
+
 
 	/* Configure MBUS and enable DRAM mod reset */
 	setbits_le32(&ccm->mbus_cfg, MBUS_RESET);
@@ -192,6 +203,8 @@ static void mctl_sys_init(struct dram_para *para)
 	setbits_le32(&ccm->dram_clk_cfg, DRAM_MOD_RESET);
 	udelay(5);
 
+	debug("Configure MBUS and enable DRAM mod reset  ok\n");
+
 	/* Unknown hack from the BSP, which enables access of mctl_ctl regs */
 	writel(0x8000, &mctl_ctl->unk_0x00c);
 }
@@ -358,7 +371,7 @@ static void mctl_bit_delay_set(struct dram_para *para)
 			(struct sunxi_mctl_phy_reg *)SUNXI_DRAM_PHY0_BASE;
 	int i, j;
 	u32 val;
-
+	debug("Now at:mctl_bit_delay_set start \n");
 	for (i = 0; i < 4; i++) {
 		val = readl(&mctl_phy->dx[i].bdlr0);
 		for (j = 0; j < 4; j++)
@@ -409,6 +422,8 @@ static void mctl_bit_delay_set(struct dram_para *para)
 		val += 0x0a0a0a0a;
 		writel(val, &mctl_phy->acbdlr[i]);
 	}
+
+	debug("Now at:mctl_bit_delay_set end \n");
 }
 
 static bool mctl_channel_init(struct dram_para *para)
@@ -437,6 +452,7 @@ static bool mctl_channel_init(struct dram_para *para)
 	clrsetbits_le32(&mctl_phy->dsgcr, BIT(0), 0x440060);
 	clrbits_le32(&mctl_phy->vtcr[1], BIT(1));
 
+	debug("Now at: TODO: VT compensation \n");
 	for (i = 0; i < 4; i++)
 		clrsetbits_le32(&mctl_phy->dx[i].gcr[0], 0xe00, 0x800);
 	for (i = 0; i < 4; i++)
@@ -466,6 +482,7 @@ static bool mctl_channel_init(struct dram_para *para)
 		clrsetbits_le32(&mctl_phy->dtcr[0], 0xF0000000, 0x10000040);
 	else
 		clrsetbits_le32(&mctl_phy->dtcr[0], 0xF0000000, 0x10000000);
+
 	if (para->clk <= 792) {
 		if (para->clk <= 672) {
 			if (para->clk <= 600)
@@ -478,6 +495,7 @@ static bool mctl_channel_init(struct dram_para *para)
 	} else {
 		val = 0x600;
 	}
+	debug("Now at: FIXME: NOT REVIEWED YET ok\n");
 	/* FIXME: NOT REVIEWED YET */
 	clrsetbits_le32(&mctl_phy->zq[0].zqcr, 0x700, val);
 	clrsetbits_le32(&mctl_phy->zq[0].zqpr[0], 0xff,
@@ -491,16 +509,20 @@ static bool mctl_channel_init(struct dram_para *para)
 	setbits_le32(&mctl_phy->zq[1].zqpr[0], ((CONFIG_DRAM_ZQ >> 8) & 0xf00) - 0x100);
 	setbits_le32(&mctl_phy->zq[1].zqpr[0], (CONFIG_DRAM_ZQ & 0xff0000) >> 4);
 	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
+	debug("Now at: for in\n");
 		for (i = 1; i < 14; i++)
 			writel(0x06060606, &mctl_phy->acbdlr[i]);
+	debug("Now at: for end\n");
 	}
 
 	val = PIR_ZCAL | PIR_DCAL | PIR_PHYRST | PIR_DRAMINIT | PIR_QSGATE |
 	      PIR_RDDSKW | PIR_WRDSKW | PIR_RDEYE | PIR_WREYE;
 	if (para->type == SUNXI_DRAM_TYPE_DDR3)
 		val |= PIR_DRAMRST | PIR_WL;
-	mctl_phy_pir_init(val);
+	debug("doing mctl_phy_pir_init-error-skip\n");
+//	mctl_phy_pir_init(val);
 
+	debug("Now at: TODO: DDR4 types\n");
 	/* TODO: DDR4 types ? */
 	for (i = 0; i < 4; i++)
 		writel(0x00000909, &mctl_phy->dx[i].gcr[5]);
@@ -518,7 +540,7 @@ static bool mctl_channel_init(struct dram_para *para)
 			val = 0x2020;
 		clrsetbits_le32(&mctl_phy->dx[i].gcr[3], 0x3030, val);
 	}
-
+	debug("Now at: mctl_bit_delay_set\n");
 	mctl_bit_delay_set(para);
 	udelay(1);
 
@@ -528,7 +550,7 @@ static bool mctl_channel_init(struct dram_para *para)
 		clrbits_le32(&mctl_phy->dx[i].gcr[3], ~0x3ffff);
 	udelay(10);
 
-	if (readl(&mctl_phy->pgsr[0]) & 0xff00000) {
+//	if (readl(&mctl_phy->pgsr[0]) & 0xff00000) {
 		/* Oops! There's something wrong! */
 		debug("PLL = %x\n", readl(0x3001010));
 		debug("DRAM PHY PGSR0 = %x\n", readl(&mctl_phy->pgsr[0]));
@@ -536,15 +558,17 @@ static bool mctl_channel_init(struct dram_para *para)
 			debug("DRAM PHY DX%dRSR0 = %x\n", i, readl(&mctl_phy->dx[i].rsr[0]));
 		debug("Error while initializing DRAM PHY!\n");
 
-		return false;
-	}
+//		return false;
+//	}
 
 	if (sunxi_dram_is_lpddr(para->type))
 		clrsetbits_le32(&mctl_phy->dsgcr, 0xc0, 0x40);
 	clrbits_le32(&mctl_phy->pgcr[1], 0x40);
 	clrbits_le32(&mctl_ctl->dfimisc, BIT(0));
 	writel(1, &mctl_ctl->swctl);
+	debug("Now at mctl_await_completion(&mctl_ctl->swstat, 1, 1) \n");
 	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
+	debug("Now ended mctl_await_completion(&mctl_ctl->swstat, 1, 1) \n");
 	clrbits_le32(&mctl_ctl->rfshctl3, BIT(0));
 
 	setbits_le32(&mctl_com->unk_0x014, BIT(31));
@@ -552,6 +576,8 @@ static bool mctl_channel_init(struct dram_para *para)
 	writel(0x7ff, &mctl_com->maer1);
 	writel(0xffff, &mctl_com->maer2);
 
+	debug("channel init  ok\n");
+
 	return true;
 }
 
@@ -685,9 +711,12 @@ unsigned long sunxi_dram_init(void)
 	clrbits_le32(0x7010318, 0x3f);
 
 	mctl_auto_detect_rank_width(&para);
+	debug("mctl_auto_detect_rank_width ok\n");
 	mctl_auto_detect_dram_size(&para);
+	debug("mctl_auto_detect_dram_size ok\n");
 
 	mctl_core_init(&para);
+	debug("mctl_core_init ok\n");
 
 	size = mctl_calc_size(&para);
 
-- 

